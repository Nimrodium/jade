use std::{
    fs::File,
    io::{Read, Write},
};

use serde_derive::Deserialize;
use toml::{Table, Value};

use crate::composer::JadeError;
#[derive(Deserialize, Debug)]
pub struct JadeFlake {
    #[serde(rename = "Mod")]
    pub mod_table: Mod,
    #[serde(rename = "Download")]
    pub download: Download,
}

#[derive(Deserialize, Debug)]
pub struct Mod {
    pub game: String,
    pub name: String,
    pub depends: Vec<String>,
    pub tags: Option<Vec<String>>,
}

#[derive(Deserialize, Debug)]
pub struct Download {
    pub filename: String,
    pub url: String,
    pub format: String,
    #[serde(rename = "hash-format")]
    pub hash_format: String,
    pub target: Option<String>,
    pub dest: Option<String>,
}

/// locked instance, autogenerated
pub struct JadeLock {
    table: Table,
    backing_file: String,
}
impl JadeLock {
    pub fn new(f: &str) -> Self {
        Self {
            table: Table::new(),
            backing_file: f.to_string(),
        }
    }
    // pub fn load_or_new(f:&str) -> Result<Self,JadeError>{
    //     let mut file = match File::open(f){
    //         Ok(_) => todo!(),
    //         Err(_) => ,
    //     }
    // }
    pub fn load(f: &str) -> Result<Self, JadeError> {
        let mut file = File::open(f)
            .map_err(|e| JadeError::Error(format!("failed to open lock file `{f}`: {e}")))?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)
            .map_err(|e| JadeError::Error(format!("failed to read lock file `{f}`: {e}")))?;
        let table: Table = contents
            .parse()
            .map_err(|e| JadeError::Error(format!("failed to parse lock file `{f}`: {e}")))?;
        println!("loaded lock file {table}");
        Ok(Self {
            table,
            backing_file: f.to_string(),
        })
    }

    pub fn write_to_disk(&self) -> Result<(), JadeError> {
        let mut file = File::create(&self.backing_file).map_err(|e| {
            JadeError::Error(format!(
                "failed to write lock file `{}`: {e}",
                self.backing_file,
            ))
        })?;
        let serialized = &toml::to_string(&self.table).map_err(|e| {
            JadeError::Error(format!(
                "failed to serialize lock file `{}`: {e}",
                self.backing_file
            ))
        })?;
        file.write_all(serialized.as_bytes()).map_err(|e| {
            JadeError::Error(format!(
                "failed to write to lock file `{}`: {e}",
                self.backing_file
            ))
        })?;
        Ok(())
    }
    pub fn add_lock(&mut self, pkg: &str, hash: &str) -> Result<(), JadeError> {
        // if self.table.contains_key(pkg) {
        //     return Err(JadeError::Error(format!(
        //         "attempted to lock `{pkg}` but it is already locked in `{}`",
        //         self.backing_file
        //     )));
        // }
        self.table
            .insert(pkg.to_string(), Value::String(hash.to_string()));
        Ok(())
    }
    pub fn get_lock(&self, pkg: &str) -> Option<String> {
        self.table
            .get(pkg)
            .map(|v| v.as_str().map(|s| s.to_string()).unwrap())
    }
}
